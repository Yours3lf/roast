<html>
<style>
    body {
        background-color:#EBECF0;
        margin-top: 20px;
        margin-left: 10px;
        font-family: Verdana;
    }

    .propertySectionTitle {
        width: 100%;
        display: block;
        margin-bottom: 10px;
        margin-top: 20px;
        text-align: center;
        color: #9397a4;
        text-shadow: 1px 1px 1px #fff;
        font-weight: bold;
    }

    #propertiesInputForm{
        display: flex;
        flex-direction: column;
    }

    #propertiesInputForm > div{
        display: flex;
        flex-direction: row;
        justify-content: space-evenly;
    }

    input {
        margin: 5px;
        width: 200px;
        box-shadow: inset 2px 2px 5px #babecc, inset -5px -5px 10px #fff;
        border-radius: 30px;
        border: 0;
        height: 30px;
        padding: 16px;
        outline: 0;
        text-shadow: 1px 1px 0 white;
        background-color: #EBECF0;
        transition: all 0.2s ease-in-out;
        color: #676767;
    }

    input:focus {
        box-shadow: inset 1px 1px 2px #babecc, inset -1px -1px 2px #fff
    }

    input:disabled {
        box-shadow: none;
        border: 1px solid #bebebe;
    }

    #actions{
        display: flex;
        flex-direction: column;
        justify-content: space-evenly;
        align-items: center;
        margin-right: 10px;
    }

    .actionButton{
        text-align: center;
        width: 50px;
        height: 50px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        font-size: 13px;
    }

    #backgroundBlur {
        position: fixed;
        backdrop-filter: blur(5px);
        /*backdrop-filter: brightness(40%);*/
        z-index: 999;
        width: 100%;
        height: 100%;
        left: 0;
        top: 0;
        visibility: hidden;
    }

    #websocketMessages {
        width: 98%;
        height: 150px;
        overflow-x: hidden;
        overflow-y: scroll;
        box-shadow: inset 2px 2px 5px #babecc, inset -5px -5px 10px #fff;
        border-radius: 10px;
        border: 0;
        padding-left: 15px;
        outline: 0;
        text-shadow: 1px 1px 0 white;
        background-color: #ececec;
        padding-top: 10px;
        color: #676767;
        font-size: 13px;
    }

    #websocketMessages::-webkit-scrollbar {
        width: 20px;
    }

    #websocketMessages::-webkit-scrollbar-track {
    }

    #websocketMessages::-webkit-scrollbar-thumb {
        border-radius: 20px;
        background: #babecc;
        border: 1px solid #9b9b9b;
    }

    #websocketMessages::-webkit-scrollbar-thumb:hover {
        background: #a9adbb;
    }

    #websocketMessages::-webkit-scrollbar-thumb:active {
        background: #989caa;
    }

    .propertiesIcon {
        opacity: 0.5;
        cursor: pointer;
        transition: transform 0.5s;
        padding: 5px;
    }

    .propertiesIcon:hover {
        transform: rotate(90deg);
    }

    .propertiesIcon:active{
        opacity: 0.75;
    }

    .propertiesDialog {
        position: fixed;
        left: 0;
        right: 0;
        margin: 5% auto;
        width: 700px;
        padding: 20px;
        border-radius: 20px;
        box-shadow: -5px -5px 20px #b0b0b0, 5px 5px 20px black;
        background-color: #EBECF0;
        visibility: hidden;
        z-index: 99999;
    }

    .propertiesTitle {
        width: 100%;
        display: block;
        text-align: center;
        margin-bottom: 20px;
        color: #9397a4;
        text-shadow: 1px 1px 1px #fff;
        font-weight: bold;
        font-size: 2em;
    }

    .button {
        border: 0;
        outline: 0;
        border-radius: 20px;
        background-color: #ebecf0;
        text-shadow: 1px 1px 0 white;
        box-shadow: -5px -5px 10px #fff, 5px 5px 10px #babecc;
        transition: all 0.2s ease-in-out;
        padding: 5px 8px 5px 8px;
        text-decoration: none;
        cursor: pointer;
        color: #676767;
        font-weight: bold;
        user-select: none;
    }

    .button:hover {
        box-shadow: -2px -2px 5px #fff, 2px 2px 5px #babecc;
    }

    .button:active {
        box-shadow: inset 1px 1px 2px #babecc, inset -1px -1px 2px #fff;
    }

    .closeButton {
        position: absolute;
        right: 15px;
        top: 12px;
    }

    .lineChart {
        margin: 0px 10px 0px 10px;
        padding: 10px;
        border-radius: 20px;
        background-color: #ebecf0;
        box-shadow: -5px -5px 10px #fff, 5px 5px 10px #babecc;
    }

    .thermalCam {
        width: 320px;
        height: 240px;
        background-color: grey;
        vertical-align: top;
        margin: 0px 10px 20px 10px;
        border-radius: 20px;
        background-color: #ebecf0;
        box-shadow: -5px -5px 10px #fff, 5px 5px 10px #babecc;
        background-image: url(img/noise.png);
    }

    .controller {
        box-shadow: -5px -5px 10px #fff, 5px 5px 10px #babecc;
        border-radius: 20px;
        background-color: #d1d4e0;
        width: 50px;
        height: 300px;
        display: flex;
        margin: 20px;
        user-select: none;
        transition: all 0.2s ease-in-out;
    }

    .controller:hover {
        box-shadow: -2px -2px 5px #fff, 2px 2px 5px #babecc;
    }

    .controller > span {
        width: inherit;
        background-color: #ebecf0;
        background-size: 100% 100%;
        display: block;
        border-radius: 20px;
        align-self: flex-end;
    }

    .controller > span > span {
        display: flex;
        height: 100%;
        color: #555;
        flex-direction: column;
        justify-content: flex-end;
        align-items: center;
        position: relative;
        bottom: 15px;
    }

    .fanImage {
        opacity: 0.75;
        animation: spin 1.35s linear infinite;
    }

    @keyframes spin 
    {
        100% 
        {
            transform: rotate(360deg);
        }
    }
</style>
<body>
    <!--
    Roast properties:
        date time, roast name, blend, individual bean types, batch, weights, volumes,
        density calculation, moisture, bean screen size, ambient temp/humidity/pressure,
        end weight, end volume, end density
    -->
    <div id="roastProperties" class="propertiesDialog">
        <span class="closeButton button" onclick="hideRoastProperties();">X</span>
        <span class="propertiesTitle">Roast Properties:</span>
        <div id="propertiesInputForm">
            <div>
                <input type="text" id="roastName" placeholder="Roast Name" />
                <input type="date" readonly="readonly" disabled id="roastDate" title="Roast Date (auto filled)" />
                <input type="time" readonly="readonly" disabled id="roastTime" title="Roast Time (auto filled)" />
            </div>
            <span class="propertySectionTitle">Pre Roast Bean Data</span>
            <div>
                <input type="text" id="beanType" placeholder="Bean Type" />
                <input type="number" placeholder="Moisture Content (%)" />
                <input type="number" placeholder='Bean Screen Size (1/64")' />
            </div>
            <div>
                <input type="number" placeholder="Bean Weight (g)" />
                <input type="number" placeholder="Bean Volume (mL)" />
                <input type="number" placeholder="Density (g/mL)" />
            </div>
            <span class="propertySectionTitle">Post Roast Bean Data</span>
            <div>
                <input type="number" placeholder="End Weight (g)" />
                <input type="number" placeholder="End Volume (mL)" />
                <input type="number" placeholder="End Density (g/mL)" />
            </div>
            <span class="propertySectionTitle">Ambient Values</span>
            <div>
                <input type="number" readonly="readonly" disabled placeholder="Temperature (°C)" />
                <input type="number" readonly="readonly" disabled placeholder="Humidity (%)" />
                <input type="number" readonly="readonly" disabled placeholder="Pressure (atm)" />
            </div>
        </div>
        <span class="propertySectionTitle">Connection settings</span>
        <div style="margin-top: 20px; margin-bottom: 10px; ">
            <input type="text" id="wsAddress" placeholder="Websocket address: ws://xxx.xxx.xxx.xxx:xxxxx" style=" width: 350px; margin-right: 10px; "/> 
            <span class="button" onclick="connect()">Connect</span>
        </div>
        <div id="websocketMessages"></div>
    </div>

    <div id="backgroundBlur"></div>

    <div style="display: flex; flex-direction: row;">
        <div id="actions">
            <div class="button actionButton" onclick="showRoastProperties();" title="Start Roasting (Drying Phase Start)">
                <img src="img/properties.png" width="40" class="propertiesIcon"  />
                <!--Icon created by Freepik - Flaticon-->
            </div>

            <div class="button actionButton" title="Start Roasting (Drying Phase Start)">
                <span>START</span>
            </div>

            <div class="button actionButton" title="Insert Drying Phase End Event">
                <span>DRY<br />END</span>
            </div>

            <div class="button actionButton" title="Insert First Crack Start Event">
                <span>FC<br />START</span>
            </div>

            <div class="button actionButton" title="Insert First Crack End Event">
                <span>FC<br />END</span>
            </div>

            <div class="button actionButton" title="Insert Second Crack Start Event">
                <span>SC<br />START</span>
            </div>

            <div class="button actionButton" title="Insert Second Crack End Event">
                <span>SC<br />END</span>
            </div>

            <div class="button actionButton" title="Stop Roasting and Start Cooldown">
                <span>STOP</span>
            </div>
        </div>

        <canvas id="lineChart" class="lineChart">
            Your browser does not support the canvas element.
        </canvas>

        <div style="display: flex; flex-direction: column;">
            <canvas id="thermalCamera" width="320" height="240" class="thermalCam">
                Your browser does not support the canvas element.
            </canvas>

            <div id="controllers" style="display: flex; flex-direction: row; justify-content: space-evenly;">
                <div id="fanController" class="controller" title="Cooling Fan Control">
                    <span style="height: 70%;">
                        <span><img src="img/fan.png" width="30" class="fanImage" /></span>
                        <!--Icon created by Dreamstale - Flaticon-->
                    </span>
                </div>

                <div id="motorController" class="controller" title="Drum Motor Control">
                    <span style="height: 70%;">
                        <span><img src="img/motor.png" width="50" style="opacity:0.75; rotate: 270deg;" /></span>
                        <!--Icon created by monkik - Flaticon-->
                    </span>
                </div>

                <div id="motorController" class="controller" title="Heating Element Control">
                    <span style="height: 70%;">
                        <span><img src="img/fire.png" width="40" style="opacity:0.75;" /></span>
                        <!--Icon created by Those Icons - Flaticon-->
                    </span>
                </div>
            </div>
        </div>
    </div>


    <script>
        // Heating elements:
        // afterburner 230v (2 wire)
        // quartz heater 115v each
        //
        // Motors to be controlled:
        // dc exhaust fan 12v 0.2a (2 wire)
        // dc logic board cooling fan 12v 0.2a (2 wire)
        // drum motor 16v (2 wire)
        // afterburner draw fan 230v
        // scroll / cooling fan 230v
        //
        // On/off switch:
        // light bulb 230v
        //
        // Sensors:
        // draw fan thermocouple
        // exhaust fan thermocouple
        // main chamber thermocouple
        // thermal camera 3.3v

        var isDown = false;
        var initialYPos = 0.0;
        var clickedElem = undefined;
        var thermalCamUpdate = true;

        document.addEventListener("mouseup", controlFunc);
        document.addEventListener("mousemove", controlFunc);

        for (c of document.getElementsByClassName("controller")) {
            c.addEventListener("mousedown", controlFunc);

            c.addEventListener("touchstart", controlFunc);
            c.addEventListener("touchend", controlFunc);
            c.addEventListener("touchmove", controlFunc);
        }

        function controlMove(initial, yPos, elem) {
            var curPercentage = elem.firstElementChild.clientHeight / elem.clientHeight;
            var delta = (initial - yPos);
            var percentage = (curPercentage + delta / elem.clientHeight) * 100;

            if (percentage > 100)
                percentage = 100;
            else if (percentage < 0)
                percentage = 0;
            elem.firstElementChild.style = "height: " + percentage + "%;";

            if (elem.getElementsByTagName("img")[0].className == "fanImage") {
                var animLen = 4 - 3.8 * percentage / 100;
                if (percentage == 0) {
                    elem.getElementsByTagName("img")[0].style = "animation: none;";
                }
                else {
                    elem.getElementsByTagName("img")[0].style = "animation: spin " + animLen + "s linear infinite;";
                }
            }
        }

        function controlFunc(e) {
            if (e.type == "mousedown") {
                isDown = true;
                initialYPos = e.y;
                clickedElem = this;
            }
            else if (e.type == "touchstart") {
                isDown = true;
                initialYPos = e.targetTouches[0].clientY;
                clickedElem = this;
            }
            else if (e.type == "mousemove") {
                if (isDown) {
                    controlMove(initialYPos, e.y, clickedElem);
                    initialYPos = e.y;
                }
            }
            else if (e.type == "touchmove") {
                if (isDown) {
                    controlMove(initialYPos, e.targetTouches[0].clientY, clickedElem);
                    initialYPos = e.targetTouches[0].clientY;
                }
            }
            else if (e.type == "mouseup" || e.type == "touchend") {
                isDown = false;
            }

            if (isDown) {
                e.preventDefault();
            }
        }

        function showRoastProperties() {
            document.getElementById('roastProperties').style.visibility = "visible";
            document.getElementById('backgroundBlur').style.visibility = "visible";
            document.getElementsByClassName('fanImage')[0].style.animationPlayState = "paused";
            console.log(document.getElementsByClassName('fanImage'));
            thermalCamUpdate = false;
        }
        function hideRoastProperties() {
            document.getElementById('roastProperties').style.visibility = "hidden";
            document.getElementById('backgroundBlur').style.visibility = "hidden";
            document.getElementsByClassName('fanImage')[0].style.animationPlayState = "running";
            thermalCamUpdate = true;
        }

        class LineChart {
            #horizontalMinVal;
            #horizontalMaxVal;
            #verticalMinVal;
            #verticalMaxVal;
            #canvasWidth;
            #canvasHeight;
            #ctx;
            #prevH;
            #prevV;
            #vertAxisOffsetX;
            #dataPointCounter;

            constructor(c, cWidth, cHeight, hMinVal, hMaxVal, vMinVal, vMaxVal) {
                this.#ctx = c;
                this.#canvasWidth = cWidth;
                this.#canvasHeight = cHeight;
                this.#horizontalMinVal = hMinVal;
                this.#horizontalMaxVal = hMaxVal;
                this.#verticalMinVal = vMinVal;
                this.#verticalMaxVal = vMaxVal;
                this.#vertAxisOffsetX = 0;
                this.#dataPointCounter = 0;
            }

            #valToCanvasYoffset(v) {
                var spaceAvailable = this.#canvasHeight - 40 * 2;
                return this.#canvasHeight - 40 - (v - this.#verticalMinVal) / (this.#verticalMaxVal - this.#verticalMinVal) * spaceAvailable;
            }

            #drawHorizontalLines(v, xOffset) {
                var line = new Path2D();
                var yOffset = this.#valToCanvasYoffset(v);
                line.moveTo(xOffset + 15, yOffset);
                line.lineTo(this.#canvasWidth - 40, yOffset);
                this.#ctx.stroke(line);
            }

            #drawVerticalAxisText(v) {
                var lineOffsetY = this.#valToCanvasYoffset(v);
                this.#ctx.fillText(v, 5, lineOffsetY + 7);
                return this.#ctx.measureText(v).width;
            }

            #valToCanvasXoffset(v, offsetX) {
                var spaceAvailable = this.#canvasWidth - 40 - (offsetX + 20);
                return offsetX + 20 + (v - this.#horizontalMinVal) / (this.#horizontalMaxVal - this.#horizontalMinVal) * spaceAvailable;
            }

            #drawHorizontalAxisText(v, vertAxisOffsetX) {
                var offsetX = this.#valToCanvasXoffset(v, vertAxisOffsetX);

                var textWidth = this.#ctx.measureText(v).width;

                this.#ctx.fillText(v, offsetX - textWidth / 2, this.#canvasHeight - 10);
            }

            #drawVertixalLines(v, vertAxisOffsetX, offsetY) {
                var offsetX = this.#valToCanvasXoffset(v, vertAxisOffsetX);

                var line = new Path2D();
                line.moveTo(offsetX, this.#canvasHeight - 40 + offsetY);
                line.lineTo(offsetX, 40);
                this.#ctx.stroke(line);
            }

            drawLineChartBackground(
                horizontalAxisTitleStr, verticalAxisTitleStr,
                horizontalLabelArray, verticalLabelArray
            ) {
                //vertical axis title
                this.#ctx.font = "20px Times New Roman";
                this.#ctx.fillStyle = "black";
                this.#ctx.fillText(verticalAxisTitleStr, 10, 20);

                //horizontal axis title
                var horizontalAxisTextSize = this.#ctx.measureText(horizontalAxisTitleStr).width;
                this.#ctx.fillText(horizontalAxisTitleStr, this.#canvasWidth - horizontalAxisTextSize - 20, this.#canvasHeight - 10);

                //draw vertical axis texts
                for (var i of verticalLabelArray) {
                    this.#vertAxisOffsetX = Math.max(this.#vertAxisOffsetX, this.#drawVerticalAxisText(i));
                }

                //draw horizontal axis texts
                for (var i of horizontalLabelArray) {
                    this.#drawHorizontalAxisText(i, this.#vertAxisOffsetX);
                }

                //draw horizontal lines
                this.#ctx.strokeStyle = 'rgba(0, 0, 0, 0.25)';
                this.#drawHorizontalLines(this.#verticalMinVal, this.#vertAxisOffsetX + 5);
                this.#drawHorizontalLines(this.#verticalMaxVal, this.#vertAxisOffsetX + 5);
                for (var i of verticalLabelArray) {
                    this.#drawHorizontalLines(i, this.#vertAxisOffsetX);
                }


                //draw vertical lines
                this.#drawVertixalLines(this.#horizontalMinVal, this.#vertAxisOffsetX, 0);
                this.#drawVertixalLines(this.#horizontalMaxVal, this.#vertAxisOffsetX, 0)
                for (var i of horizontalLabelArray) {
                    this.#drawVertixalLines(i, this.#vertAxisOffsetX, 5);
                }
            }

            addDataPoint(h, v) {
                if (this.#dataPointCounter++ == 0) {
                    this.#prevH = h;
                    this.#prevV = v;
                    return;
                }

                this.#ctx.strokeStyle = 'rgba(0, 0, 0, 1)';
                this.#ctx.lineCap = "round";
                this.#ctx.lineJoin = "round";
                this.#ctx.lineWidth = 4.0;
                var line = new Path2D();
                var xfrom = this.#valToCanvasXoffset(this.#prevH, this.#vertAxisOffsetX);
                var xto = this.#valToCanvasXoffset(h, this.#vertAxisOffsetX);
                var yfrom = this.#valToCanvasYoffset(this.#prevV);
                var yto = this.#valToCanvasYoffset(v);
                line.moveTo(xfrom, yfrom);
                line.lineTo(xto, yto);
                this.#ctx.stroke(line);
                this.#prevH = h;
                this.#prevV = v;
            }
        }

        { //draw line chart
            var canvas = document.getElementById("lineChart");
            var ctx = canvas.getContext("2d");

            var canvasWidth = 900;
            var canvasHeight = 600;

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            canvas.style.visibility = "visible";

            // Get the DPR and size of the canvas
            const dpr = window.devicePixelRatio;
            const rect = canvas.getBoundingClientRect();

            // Set the "actual" size of the canvas
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            // Scale the context to ensure correct drawing operations
            ctx.scale(dpr, dpr);

            // Set the "drawn" size of the canvas
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;

            canvasWidth = rect.width;
            canvasHeight = rect.height;

            //canvas coordinate system:
            //0...w
            //0
            //.
            //.
            //h

            //supported primites: rectangles and paths

            //rectangles
            //fillRect(x, y, w, h) -> draws filled rectangle
            //strokeRect(x, y, w, h) -> draws outline
            //clearRect(x, y, w, h) -> clears area

            //paths
            //beginPath() -> create new path, then can build up the path from here
            //closePath() -> tries to close the shape by drawing a straight line from the current point to the start
            //stroke() -> draws path outline
            //fill() -> fills the path's content area (any open shapes are closed)
            //moveTo(x, y) -> move the path drawing point (lift and move the pen)
            //lineTo(x, y) -> draw a line from current pos to coords

            //Path2D() object
            //combines all objects, can combine paths
            //var rectangle = new Path2D();
            //rectangle.rect(10, 10, 50, 50);
            //ctx.stroke(rectangle);
            //.addPath()
            //.closePath()
            //.moveTo()
            //.lineTo()
            //

            //ctx.fillStyle = rgba(r, g, b, a) -> 0..255 fill color!
            //ctx.strokeStyle = rgba()
            //ctx.lineWidth = x -> linewidth in units?
            //ctx.lineCap = "butt" "round" "square" -> line ending styles
            //ctx.lineJoin = "round" "bevel" "miter" -> how line segments are joined

            //text
            //ctx.font = "20px Times New Roman"
            //ctx.textAlign = "start" "end" "left" "right" "center"
            //ctx.fillStyle = "black";
            //ctx.fillText("string", x, y);
            //ctx.measureText("string").width -> returns the width in pixels when the text is drawn

            //ctx.save() -> save / restore canvas state
            //ctx.restore()


            //https://www.wikiwand.com/en/Coffee_roasting
            //22c  unroasted
            //165c drying phase
            //196c cinnamon roast (right after first crack)
            //205c new england roast
            //210c american roast
            //219c city roast (common for speciality coffee)
            //225c full city roast (beginning of second crack)
            //230c vienna roast
            //240c french roast
            //245c italian roast

            //0 = 400c
            //canvasHeight = 0c

            //could add minvalue, maxvalue for each axis
            //then value array to draw lines and text to
            //that would make adding data points easier too
            var lineChart = new LineChart(ctx, canvasWidth, canvasHeight, 0, 25, 0, 300);
            lineChart.drawLineChartBackground(
                "Time (m)", "Temp °C",
                [5, 10, 15, 20], [50, 100, 150, 200, 250]
            );

            //todo multiple curves!

            //test data for drawing a curve
            var dataSet = [
                22, //minute 0, eg starting
                43, 113, 140, //drying phase
                165, 177, 185, 192, 196, //yellowing, fc
                204, 213, 220, //development
                225, 226, 227, //second crack
                229, 232, 236, 239, 242, 245, //15-20mins
                199, 143, 93, 54, 25 //20-25mins
            ];
            for (var i = 0; i < dataSet.length; ++i)
                lineChart.addDataPoint(i, dataSet[i]);

        }

        function saturate(x) {
            return Math.min(1.0, Math.max(x, 0.0));
        }

        function componentToHex(c) {
            var hex = c.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        }

        function rgbToHex(r, g, b) {
            return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
        }

        function colorRamp(v) {
            v = 2.0 * v;
            r = v - 0.0;
            g = v - 1.0;
            b = v - 2.0;

            r = 1.0 - r * r;
            g = 1.0 - g * g;
            b = 1.0 - b * b;

            r = Math.floor(saturate(r) * 255);
            g = Math.floor(saturate(g) * 255);
            b = Math.floor(saturate(b) * 255);

            return rgbToHex(r, g, b);
        }

        function drawThermalCameraOutput(temperatures) {
            if (thermalCamUpdate) {
                var canvas = document.getElementById("thermalCamera");
                canvas.style.visibility = "visible";
                canvas.width = 320;
                canvas.height = 240;
                var canvasCtx = canvas.getContext("2d");
                for (x = 0; x < 32; ++x)
                    for (y = 0; y < 24; ++y) {
                        //const randomColor = Math.floor(Math.random() * 16777215).toString(16);
                        //randomTemp = Math.random(); //pretend that it's normalised to 0..1

                        temp = temperatures[32 * (23 - y) + x];
                        //map temperatures to 0..1
                        minTemp = 10.0; //-40c
                        maxTemp = 40.0; //+300c
                        temp = (temp - minTemp) / (maxTemp - minTemp);

                        canvasCtx.fillStyle = colorRamp(temp);
                        canvasCtx.fillRect(x * 10, y * 10, 10, 10);
                    }
            }
        }

        function connect() {
            try {
                serverURL = document.getElementById("wsAddress").value;
                webSocket = new WebSocket(serverURL);
                webSocket.binaryType = 'arraybuffer';

                webSocket.onerror = (event) => {
                    document.getElementById("websocketMessages").innerHTML += "Failed to connect to " + serverURL + "<br>";
                }

                webSocket.onclose = (event) => {
                    document.getElementById("websocketMessages").innerHTML += "onclose" + "<br>";

                    var tcc = document.getElementById("thermalCamera");
                    var tccCtx = tcc.getContext("2d");
                    tccCtx.clearRect(0, 0, 320, 240);
                }

                webSocket.onopen = (event) => {
                    document.getElementById("websocketMessages").innerHTML += "onopen" + "<br>";
                    //webSocket.send(("a").repeat(65536*2));
                    webSocket.send("hello server!");
                }

                webSocket.onmessage = (event) => {
                    //document.getElementById("websocketMessages").innerHTML += "onmessage " + (typeof event.data) + "<br>";
                    if (typeof event.data == "string") {
                        document.getElementById("websocketMessages").innerHTML += event.data + "<br>";
                    }
                    else if (typeof event.data == "object") {
                        arrayBuf = event.data;
                        floatArray = new Float32Array(arrayBuf);
                        drawThermalCameraOutput(floatArray);
                    }
                }
            }
            catch (error) {
                document.getElementById("websocketMessages").innerHTML += error.message + "<br>";
            }
        }
    </script>
</body>
</html>

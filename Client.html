<html>
<style>
    .controller {
        outline: 2px solid #aaa;
        border-radius: 20px;
        background-color: #555;
        width: 300px;
        height: 50px;
        display: block;
        margin: 20px;
        user-select: none;
    }

    .controller > span {
        height: inherit;
        background-color: #fff;
        background-size: 100% 100%;
        display: block;
        border-radius: 20px;
    }

    .controller > span > span {
        display: flex;
        height: inherit;
        justify-content: left;
        align-items: center;
        color: #555;
        padding-left: 15px;
    }

    .controller > span > span > img {
        height: 30px;
        opacity: 0.75;
        animation: spin 1.35s linear infinite;
    }

    @keyframes spin 
    {
        100% 
        {
            transform: rotate(360deg);
        }
    }
</style>
<body>
    <div id="fanController" class="controller">
        <span style="width: 70%;">
            <span><img src="img/fan.png"/></span>
        </span>
    </div>

    <canvas id="thermalCamera" width="0" height="0" style="border:1px solid #c3c3c3; visibility: hidden;">
        Your browser does not support the canvas element.
    </canvas>

    <canvas id="lineChart" style="border:1px solid #c3c3c3; visibility: hidden;">
        Your browser does not support the canvas element.
    </canvas>

    <div id="test"></div>

    <div>Websocket address: <input type="text" id="wsAddress" /> <button onclick="connect()">Connect</button></div>

    <script>
        // Heating elements:
        // afterburner 120v (2 wire)
        // quartz heater 120v
        //
        // Motors to be controlled:
        // dc fan 12v 0.2a (2 wire)
        // drum motor 16v (2 wire)
        // scroll / cooling fan 120v
        //
        // On/off switch:
        // light bulb 120v
        //
        // Sensors:
        // thermocouple(s) 120v
        // thermal camera 3.3v

        var isDown = false;

        for (c of document.getElementsByClassName("controller"))
        {
            c.addEventListener("mousedown", controlFunc);
            c.addEventListener("mouseup", controlFunc);
            c.addEventListener("mousemove", controlFunc);

            c.addEventListener("touchstart", controlFunc);
            c.addEventListener("touchend", controlFunc);
            c.addEventListener("touchmove", controlFunc);
        }

        function controlMove(xPos, elem)
        {
            var percentage = (xPos - 29) / elem.clientWidth * 100;
            if (percentage > 97)
                percentage = 100;
            else if (percentage < 3)
                percentage = 0;
            elem.firstElementChild.style = "width: " + percentage + "%;";
            var animLen = 4 - 3.8 * percentage / 100;
            if (percentage == 0)
            {
                elem.getElementsByTagName("img")[0].style = "animation: none;";
            }
            else
            {
                elem.getElementsByTagName("img")[0].style = "animation: spin " + animLen + "s linear infinite;";
            }
        }

        function controlFunc(e)
        {
            if (e.type == "mousedown")
            {
                isDown = true;

                controlMove(e.x, this);
            }
            else if (e.type == "touchstart")
            {
                isDown = true;

                controlMove(e.targetTouches[0].clientX, this);
            }
            else if (e.type == "mousemove")
            {
                if (isDown)
                {
                    controlMove(e.x, this);
                }
            }
            else if (e.type == "touchmove")
            {
                if (isDown)
                {
                    controlMove(e.targetTouches[0].clientX, this);
                }
            }
            else if (e.type == "mouseup" || e.type == "touchend")
            {
                isDown = false;
            }

            if (e.type == "mousedown" || e.type == "mouseup" || e.type == "mousemove")
            {
                e.preventDefault();
            }
        }

        class LineChart {
            #horizontalMinVal;
            #horizontalMaxVal;
            #verticalMinVal;
            #verticalMaxVal;
            #canvasWidth;
            #canvasHeight;
            #ctx;
            #prevH;
            #prevV;
            #vertAxisOffsetX;
            #dataPointCounter;

            constructor(c, cWidth, cHeight, hMinVal, hMaxVal, vMinVal, vMaxVal) {
                this.#ctx = c;
                this.#canvasWidth = cWidth;
                this.#canvasHeight = cHeight;
                this.#horizontalMinVal = hMinVal;
                this.#horizontalMaxVal = hMaxVal;
                this.#verticalMinVal = vMinVal;
                this.#verticalMaxVal = vMaxVal;
                this.#vertAxisOffsetX = 0;
                this.#dataPointCounter = 0;
            }

            #valToCanvasYoffset(v)
            {
                var spaceAvailable = this.#canvasHeight - 40 * 2;
                return this.#canvasHeight - 40 - (v - this.#verticalMinVal) / (this.#verticalMaxVal - this.#verticalMinVal) * spaceAvailable;
            }

            #drawHorizontalLines(v, xOffset)
            {
                var line = new Path2D();
                var yOffset = this.#valToCanvasYoffset(v);
                line.moveTo(xOffset + 15, yOffset);
                line.lineTo(this.#canvasWidth - 40, yOffset);
                this.#ctx.stroke(line);
            }

            #drawVerticalAxisText(v)
            {
                var lineOffsetY = this.#valToCanvasYoffset(v);
                this.#ctx.fillText(v, 5, lineOffsetY + 7);
                return this.#ctx.measureText(v).width;
            }

            #valToCanvasXoffset(v, offsetX)
            {
                var spaceAvailable = this.#canvasWidth - 40 - (offsetX + 20);
                return offsetX + 20 + (v - this.#horizontalMinVal) / (this.#horizontalMaxVal - this.#horizontalMinVal) * spaceAvailable;
            }

            #drawHorizontalAxisText(v, vertAxisOffsetX)
            {
                var offsetX = this.#valToCanvasXoffset(v, vertAxisOffsetX);

                var textWidth = this.#ctx.measureText(v).width;

                this.#ctx.fillText(v, offsetX - textWidth / 2, this.#canvasHeight - 10);
            }

            #drawVertixalLines(v, vertAxisOffsetX, offsetY)
            {
                var offsetX = this.#valToCanvasXoffset(v, vertAxisOffsetX);

                var line = new Path2D();
                line.moveTo(offsetX, this.#canvasHeight - 40 + offsetY);
                line.lineTo(offsetX, 40);
                this.#ctx.stroke(line);
            }

            drawLineChartBackground(
                horizontalAxisTitleStr, verticalAxisTitleStr,
                horizontalLabelArray, verticalLabelArray
            )
            {
                //vertical axis title
                this.#ctx.font = "20px Times New Roman";
                this.#ctx.fillStyle = "black";
                this.#ctx.fillText(verticalAxisTitleStr, 10, 20);

                //horizontal axis title
                var horizontalAxisTextSize = this.#ctx.measureText(horizontalAxisTitleStr).width;
                this.#ctx.fillText(horizontalAxisTitleStr, this.#canvasWidth - horizontalAxisTextSize - 20, this.#canvasHeight - 10);

                //draw vertical axis texts
                for (var i of verticalLabelArray) {
                    this.#vertAxisOffsetX = Math.max(this.#vertAxisOffsetX, this.#drawVerticalAxisText(i));
                }

                //draw horizontal axis texts
                for (var i of horizontalLabelArray) {
                    this.#drawHorizontalAxisText(i, this.#vertAxisOffsetX);
                }

                //draw horizontal lines
                this.#ctx.strokeStyle = 'rgba(0, 0, 0, 0.25)';
                this.#drawHorizontalLines(this.#verticalMinVal, this.#vertAxisOffsetX + 5);
                this.#drawHorizontalLines(this.#verticalMaxVal, this.#vertAxisOffsetX + 5);
                for (var i of verticalLabelArray) {
                    this.#drawHorizontalLines(i, this.#vertAxisOffsetX);
                }
                

                //draw vertical lines
                this.#drawVertixalLines(this.#horizontalMinVal, this.#vertAxisOffsetX, 0);
                this.#drawVertixalLines(this.#horizontalMaxVal, this.#vertAxisOffsetX, 0)
                for (var i of horizontalLabelArray) {
                    this.#drawVertixalLines(i, this.#vertAxisOffsetX, 5);
                }
            }

            addDataPoint(h, v)
            {
                if (this.#dataPointCounter++ == 0)
                {
                    this.#prevH = h;
                    this.#prevV = v;
                    return;
                }

                this.#ctx.strokeStyle = 'rgba(0, 0, 0, 1)';
                this.#ctx.lineCap = "round";
                this.#ctx.lineJoin = "round";
                this.#ctx.lineWidth = 4.0;
                var line = new Path2D();
                var xfrom = this.#valToCanvasXoffset(this.#prevH, this.#vertAxisOffsetX);
                var xto = this.#valToCanvasXoffset(h, this.#vertAxisOffsetX);
                var yfrom = this.#valToCanvasYoffset(this.#prevV);
                var yto = this.#valToCanvasYoffset(v);
                line.moveTo(xfrom, yfrom);
                line.lineTo(xto, yto);
                this.#ctx.stroke(line);
                this.#prevH = h;
                this.#prevV = v;                
            }
        }

        { //draw line chart
            var canvas = document.getElementById("lineChart");
            var ctx = canvas.getContext("2d");

            var canvasWidth = 900;
            var canvasHeight = 500;

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            canvas.style.visibility = "visible";

            // Get the DPR and size of the canvas
            const dpr = window.devicePixelRatio;
            const rect = canvas.getBoundingClientRect();

            // Set the "actual" size of the canvas
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            // Scale the context to ensure correct drawing operations
            ctx.scale(dpr, dpr);

            // Set the "drawn" size of the canvas
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;

            //canvas coordinate system:
            //0...w
            //0
            //.
            //.
            //h

            //supported primites: rectangles and paths

            //rectangles
            //fillRect(x, y, w, h) -> draws filled rectangle
            //strokeRect(x, y, w, h) -> draws outline
            //clearRect(x, y, w, h) -> clears area

            //paths
            //beginPath() -> create new path, then can build up the path from here
            //closePath() -> tries to close the shape by drawing a straight line from the current point to the start
            //stroke() -> draws path outline
            //fill() -> fills the path's content area (any open shapes are closed)
            //moveTo(x, y) -> move the path drawing point (lift and move the pen)
            //lineTo(x, y) -> draw a line from current pos to coords

            //Path2D() object
            //combines all objects, can combine paths
            //var rectangle = new Path2D();
            //rectangle.rect(10, 10, 50, 50);
            //ctx.stroke(rectangle);
            //.addPath()
            //.closePath()
            //.moveTo()
            //.lineTo()
            //

            //ctx.fillStyle = rgba(r, g, b, a) -> 0..255 fill color!
            //ctx.strokeStyle = rgba()
            //ctx.lineWidth = x -> linewidth in units?
            //ctx.lineCap = "butt" "round" "square" -> line ending styles
            //ctx.lineJoin = "round" "bevel" "miter" -> how line segments are joined

            //text
            //ctx.font = "20px Times New Roman"
            //ctx.textAlign = "start" "end" "left" "right" "center"
            //ctx.fillStyle = "black";
            //ctx.fillText("string", x, y);
            //ctx.measureText("string").width -> returns the width in pixels when the text is drawn

            //ctx.save() -> save / restore canvas state
            //ctx.restore() 


            //https://www.wikiwand.com/en/Coffee_roasting
            //22c  unroasted
            //165c drying phase
            //196c cinnamon roast (right after first crack)
            //205c new england roast
            //210c american roast
            //219c city roast (common for speciality coffee)
            //225c full city roast (beginning of second crack)
            //230c vienna roast 
            //240c french roast
            //245c italian roast

            //0 = 400c
            //canvasHeight = 0c
            
            //could add minvalue, maxvalue for each axis
            //then value array to draw lines and text to
            //that would make adding data points easier too
            var lineChart = new LineChart(ctx, canvasWidth, canvasHeight, 0, 25, 0, 300);
            lineChart.drawLineChartBackground(
                "Time (m)", "Temp °C", 
                [5, 10, 15, 20], [50, 100, 150, 200, 250]
            );

            //todo multiple curves!

            //test data for drawing a curve
            var dataSet = [
                22, //minute 0, eg starting
                43, 113, 140, //drying phase
                165, 177, 185, 192, 196, //yellowing, fc
                204, 213, 220, //development
                225, 226, 227, //second crack
                229, 232, 236, 239, 242, 245, //15-20mins
                199, 143, 93, 54, 25 //20-25mins
            ];
            for (var i = 0; i < dataSet.length; ++i)
            lineChart.addDataPoint(i, dataSet[i]);

        }

        function saturate(x)
        {
            return Math.min(1.0, Math.max(x, 0.0));
        }

        function componentToHex(c) {
            var hex = c.toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        }

        function rgbToHex(r, g, b)
        {
            return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
        }

        function colorRamp(v)
        {
            v = 2.0 * v;
            r = v - 0.0;
            g = v - 1.0;
            b = v - 2.0;

            r = 1.0 - r * r;
            g = 1.0 - g * g;
            b = 1.0 - b * b;

            r = Math.floor(saturate(r)*255);
            g = Math.floor(saturate(g)*255);
            b = Math.floor(saturate(b)*255);

            return rgbToHex(r, g, b);
        }

        function drawThermalCameraOutput(temperatures)
        {
            var canvas = document.getElementById("thermalCamera");
            canvas.style.visibility = "visible";
            canvas.width = 320;
            canvas.height = 240;
            var canvasCtx = canvas.getContext("2d");
            for (x = 0; x < 32; ++x)
                for (y = 0; y < 24; ++y) {
                    //const randomColor = Math.floor(Math.random() * 16777215).toString(16);
                    //randomTemp = Math.random(); //pretend that it's normalised to 0..1
					
					temp = temperatures[32 * (23-y) + x];
					//map temperatures to 0..1
					minTemp = 10.0; //-40c
					maxTemp = 40.0; //+300c
					temp = (temp - minTemp) / (maxTemp - minTemp);

                    canvasCtx.fillStyle = colorRamp(temp);
                    canvasCtx.fillRect(x * 10, y * 10, 10, 10);
                }
        }

        function connect() {
            try {
                serverURL = document.getElementById("wsAddress").value;
                webSocket = new WebSocket(serverURL);
                webSocket.binaryType = 'arraybuffer';

                webSocket.onerror = (event) => {
                    document.getElementById("test").innerHTML += "Failed to connect to " + serverURL + "<br>";
                }

                webSocket.onclose = (event) => {
                    document.getElementById("test").innerHTML += "onclose" + "<br>";
                }

                webSocket.onopen = (event) => {
                    document.getElementById("test").innerHTML += "onopen" + "<br>";
                    //webSocket.send(("a").repeat(65536*2));
                    webSocket.send("hello server!");
                }

                webSocket.onmessage = (event) => {
                    document.getElementById("test").innerHTML = "onmessage " + (typeof event.data) + "<br>";
                    if (typeof event.data == "string") {
                        document.getElementById("test").innerHTML += event.data + "<br>";
                    }
                    else if (typeof event.data == "object") {
                        arrayBuf = event.data;
                        floatArray = new Float32Array(arrayBuf);
                        drawThermalCameraOutput(floatArray);
                    }
                }
            }
            catch (error) {
                document.getElementById("test").innerHTML = error.message;
            }
        }
    </script>
</body>
</html>
